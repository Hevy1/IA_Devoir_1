Evan Weisse : 
Jorick Célarier : CELJ29089807

Les actions des agents ont simplement pu être transférées sur des threads. En effet, il suffisait juste de donner l'action Agent->Update() au thread.
Cependant, sans changements supplémentaires, le console devenait illisible. En effet, alors qu'un agent était en train d'écrire en console depuis son thread, un autre thread pouvait alors commencer à prendre la main et écrire en même temps, donnant lieu donc à des coupures de messages par d'auters messages. De plus, comme les couleurs d'écriture en console étaient choisies bien avant l'écriture en console (lors du premier appel à Update()), les couleur d'écritures n'étaient plus les bonnes.
Ainsi, il fallait impérativement bloquer l'écriture en console à un seul agent à la fois. Cela a alors été effectué depuis un mutex. Tout d'abord, afin de facilement mettre en place le mutex, nous avons modifié la manière dont les agents écrivent en console : les classes des fichiers AgentOwnedStates font désormais appel aux fonctions Print() de la classe de l'agent lorsqu'il faut écrire quelque chsoe en console. De cette manière, il a alors été possible d'uniformiser la manière dont les écritures en console sont effectuées.
Les fonctions Print() font alors 4 actions principales : tout d'abord vérouiller le mutex, ensuite établir la couleur d'écriture en console, écrire ce qu'on a a écrire, et enfin déverrouiller le mutex. Cela permet alors de ne plus avoir de conflit lors de l'écriture de messages, et également d'avoir les bonnes couleurs d'écriture pour les agents.

En plus d'avoir créé Drunkard.h, Drunkard.cpp, DrunkardOwnedStates.h et DrunkardOwnedStates.cpp, nous avons apporté des modifications à plusieurs autres fichiers déjà existants.
Tout d'abord, dans main.cpp, nous avons include Drunkard.h afin ensuite de tout naturellement ajouter un Drunkard qu'on a nommé Joe. Il est a noté que nous avons ajouté "ent_Drunk_Joe" dans l'enum de EntityName.h, ainsi que le case correspondant dans la fonction GetNameOfEntity(int n).
Dans Locations.h, il a fallu rajouter les 2 lieux que sont la maison du Drunkard ("home") et l'hôpital ("hospital") dans enum location_type.
Pour que l'interaction entre Miner et Drunkard puisse se faire, nous avons rajouté dans enum message_type les types de messages "Msg_BobIsInTheSaloon" (quand un Miner rentre dans le saloon), "Msg_DrunkardWin" (quand lors du conflit c'est le Drunkard qui gagne) et "Msg_BobWin" (quand lors du conflit c'est le Miner qui gagne). Les case correspondant n'ont pas été oublié dans la fonction MsgToStr(int msg).
Enfin, toujours pour qu'il y ait interaction, nous avons modifié la classe QuenchThirst de MinerOwnedStates.cpp. Lorsque le Miner rentre dans le saloon (QuenchThirst::Enter(Miner* pMiner)), il envoie un message immédiat à un Drunkard, qui le reçoit seulement s'il est présent. La fonction QuenchThirst::OnMessage(Miner* pMiner, const Telegram& msg) a été complété avec 2 cas : en fonction de s'il reçoit un message Msg_DrunkardWin ou bien Msg_BobWin.